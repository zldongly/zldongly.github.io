# 常见垃圾回收方式

* 引用计数  
缺点：无法避免循环引用
* 追踪式垃圾回收(标记清扫) 
STW 需要挂起当前程序  
根对象：全局变量、栈中的对象  
缺点：stw时间太长
步骤：   
    1. stop the world
    2. Mark 通过root对象寻找能找到的直接或间接对象
    3. Sweep 对堆对象迭代，未标记对象加入freelist，可以清扫再分配
    4. start the world  

# 三色标记 

> 基于标记清扫  
优化思路：减少STW时长

简单描述：  
1. 根对象标记为灰色，加入队列
2. 从队列中取灰色对象  
扫描其子对象并标记为灰色，加入队列  
该对象标记为黑  
3. 重复`步骤2`直到队列为空没有灰色对象
4. 清扫未被标记的白色对象  

* 强三色一致性  
一个黑色对象不能直接引用白色对象
* 弱三色一致性  
一个黑色对象可以饮用白色对象，但这个白色对象必须被另一个灰色对象引用

## 写屏障(插入屏障)
强三色
* 黑色对象引用白色对象时把白色对象置成灰色  
* 问题：拦截栈上的引用操作影响性能，栈的引用操作频繁  
解决办法：不拦截栈的引用，在最后re-scan重扫栈需要STW  

## 删屏障
弱三色
* 灰色对象删除对白色对象的引用时，把白色对象置成灰色  
* 缺点：可能遗漏需要清除的对象  

## 混合屏障  
结合写屏障和删屏障  
* 堆之间引用采用写屏障
* 栈引用堆采用删屏障
* 堆上新申请的对象为黑色

## Sweep
两种方式清扫
* 自动清扫  
一个goroutine主动清扫
* 被动清扫  
需要分配新对象时新对象覆盖上去

# 触发条件
* 每2分钟强制出发
* 配置，下一次启动前可分配新内存的占比
