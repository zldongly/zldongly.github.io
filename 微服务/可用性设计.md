# 隔离

* 服务隔离
    * 动静分离  
        * 数据库分表，经常更新的字段和不常更新字段分开
        * 静态资源分离
    * 读写分离
* 轻重隔离
    * 核心
        * 划分等级，核心服务
    * 快慢
        * 多个下游消费者消费速度不同  
        如：kafka建不同group
    * 热点 
        * 滑动窗口发现热点
        * 支持广播，remotecache升级到localcache
* 物理隔离
    * 线程
        * 使用与java等线程调度，不同任务采用不同线程池
    * 进程
        * docker
    * 集群
        * 多集群
        * 多活
    * 机房

# 超时

* 作用：不堆积请求
* 建议  
    * C端请求建议不超过1S  
    内部rpc调用100ms，不超过300ms
    * 基础库做超时兜底  
    不要出现永不超时的情况
    * api一起定义响应时间 95th、99th

* 超时传递
    * 下游继承上游的超时策略  
    调下游时，剩余时长和配置时长取其小 min(config, left)
    * context
    * rpc元数据传递，grpc可传递context
* 双峰分布  
有一部分请求可能永远都不会被完成

# 过载保护&限流

* 令牌桶算法  
    * 速率
    * 峰值
    * 问题：以上两个参数（阈值）难以设定  
    修改需求业务后阈值就可能发生变化
* 漏桶算法
    * 恒定的流出速率
    * 问题同上

## 自适应保护
* 高负载时自动抛弃流量(CPU/内存)
* 保证系统稳定的情况下，尽可能多的服务更多的请求
> L = λ W  
L容量  
λ速率，QPS  
W处理时间，响应时间  

CPU滑动均值  
PS：压测时出现报错不要马上停止，继续加压看服务器表现

## 限流
 
 * 基于redis限流集群
    * 一个请求 请求一次redis，对redis的负载太高
    * 定时去redis请求一批quota，本地再根据令牌桶算法限流拒绝  
    最大最小公平分享(Max-Min Fairness)  
    优先给需求小的，min(剩余均值, 需要的值)

 类型 | 优点 | 缺点 | 实现 
 --- | --- | --- |---
单机限制 | 简单、可靠 | 阈值（速率、峰值）难界定，易变动 | 桶令牌:golang/x/time/ratelimit
动态流控 | 灵活、配置简单 | 实现复杂 | BFF限流
全局限流 | 不会误触发 | 需要手动配置 | 

## 熔断
> 客户端节流  
请求服务错误率过高时，开启熔断  
过段时间放一个请求尝试

# 降级
> 高负载时降低质量的回复  
丢弃一些消耗资源非核心的任务

* 高层（BFF）进行降级  
低层降级可能影响上游缓存等  
是否重要可以降级由上游调用者决定  
* 调下游失败可以返回一些过期缓存数据

# 重试
* 低层立刻重试(哪里报错哪里重试)  
避免重试级联风暴，重试放大
* 错误码传递，避免重试放大
* 控制总体重试次数不超过一定比例如1.1倍
* 减少写操作重试(难以实现业务幂等)  

# 负载均衡
* 随机
* 轮询
* 权重轮询
* 一致性hash

## 负载均衡实现
* 考虑因素
    * 负载
    * 连接数量
    * 可用性
* p2c (pick two choice)  
从连接池中随机选两个节点打分，选更优  
    * 打分参考  
        * cpu  
        server.cpu等数据在请求的response.header中  
        grpc health check
        * inflight  
        * 请求成功率
        正在处理的请求数
        * 新启动的节点需要预热   
        * 随着时间的推移健康度逐渐恢复到正常（衰减）  
        避免分值低的节点被永远抛弃
