# 隔离

* 服务隔离
    * 动静分离  
        * 数据库分表，经常更新的字段和不常更新字段分开
        * 静态资源分离
    * 读写分离
* 轻重隔离
    * 核心
        * 划分等级，核心服务
    * 快慢
        * 多个下游消费者消费速度不同  
        如：kafka建不同group
    * 热点 
        * 滑动窗口发现热点
        * 支持广播，remotecache升级到localcache
* 物理隔离
    * 线程
        * 使用与java等线程调度，不同任务采用不同线程池
    * 进程
        * docker
    * 集群
        * 多集群
        * 多活
    * 机房

# 超时

* 作用：不堆积请求
* 建议  
    * C端请求建议不超过1S  
    内部rpc调用100ms，不超过300ms
    * 基础库做超时兜底  
    不要出现永不超时的情况
    * api一起定义响应时间 95th、99th

* 超时传递
    * 下游继承上游的超时策略  
    调下游时，剩余时长和配置时长取其小 min(config, left)
    * context
    * rpc元数据传递，grpc可传递context
* 双峰分布  
有一部分请求可能永远都不会被完成

# 过载保护&限流

* 令牌桶算法  
    * 速率
    * 峰值
    * 问题：以上两个参数（阈值）难以设定  
    修改需求业务后阈值就可能发生变化
* 漏桶算法
    * 恒定的流出速率
    * 问题同上

## 自适应保护
* 高负载时自动抛弃流量(CPU/内存)
* 保证系统稳定的情况下，尽可能多的服务更多的请求
> L = λ W  
L容量  
λ速率，QPS  
W处理时间，响应时间  

CPU滑动均值  
PS：压测时出现报错不要马上停止，继续加压看服务器表现

## 限流
 


# 熔断

# 降级

# 重试

# 负载均衡
